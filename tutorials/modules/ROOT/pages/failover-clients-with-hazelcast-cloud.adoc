= Configuring a Failover Client
:url-code-sample-client-failover: https://github.com/hazelcast/hazelcast-cloud-code-samples/tree/master/client-failover
:description: In this tutorial, you'll update the code in a Java client to automatically connect to a secondary, failover cluster if it cannot connect its original, primary cluster. You'll also run a simple test to make sure that your configuration is correct and then adjust it to include exception handling.
:page-layout: tutorial
:page-product: cloud
:page-categories: Manage Clusters
:page-est-time: 30 mins

{description}

== Context

Failover is an important feature of systems that rely on near-constant availability. In Hazelcast, a failover client automatically redirects your connection from one cluster that has problems to a second running cluster.

Consider using a failover client with xref:cloud:ROOT:wan-replication.adoc[WAN replication] as part of your disaster recovery strategy.

[[step-1-setup]]
== Step 1. Cluster and Client Setup

Create two Serverless clusters that you'll use as your primary and secondary clusters and then download and connect sample Java clients to them.

. xref:cloud:ROOT:create-serverless-cluster.adoc[Create the Serverless cluster] that you'll use as your primary cluster. When the cluster is ready to use, setup details for the Java client are displayed.
. Follow the instructions in *Java Client Quick Setup* to download, extract, and connect the preconfigured Java client to your primary cluster.
. xref:cloud:ROOT:create-serverless-cluster.adoc[Create the Serverless cluster] that you'll use as your secondary cluster. 
. This time when the setup details for the Java client are displayed, from the *Java Client Advanced Setup* section record the following connection details:

** *Cluster name*
** *Discovery token*
** *Keystore and truststore password*.

. Repeat step 2 for your secondary cluster. You have two running clusters with connected Java clients.
. Now that you have checked that both Java clients can connect, shut them down. Either press kbd:[Ctrl+C] or type `exit` at the console. 

[[step-2-configuration]]
== Step 2. Configure a Failover Client

To create a failover client, update the configuration and code of the Java client for your primary cluster. 

Start by adding the keystore files from the Java client of your secondary cluster.

.	Go to the directory where you extracted the Java client for your secondary cluster and then navigate to `src/main/resources`.
. Rename the `client.keystore` and `client.trustore` files so they don't overwrite the files in your primary cluster keystore. 
. Copy both files over to the `src/main/resources` directory of your primary cluster.

Update the code in the Java client (`ClientwithSsl.java`) of your primary cluster to include a failover class and the connection details for your secondary cluster. You'll need the connection details that you recorded in <<step-1-setup, Step 1>>.

. Go to the directory where you extracted the Java client for your primary cluster and then navigate to `src/main/java/com/hazelcast/cloud`.
. Open the Java client (`ClientwithSsl.java`) and make the following updates. An link:{url-code-sample-client-failover}[example failover client] is also available for download.

.ClientwithSsl.java
[source,java]
----

import com.hazelcast.client.config.ClientFailoverConfig; // <1>

public class ClientWithSsl {

  public static void main(String[] args) throws Exception {

    ClientFailoverConfig clientFailoverConfig = new ClientFailoverConfig(); // <2>
    clientFailoverConfig.addClientConfig(getPrimaryClientConfig());
    clientFailoverConfig.addClientConfig(getSecondaryClientConfig());

    HazelcastInstance client = HazelcastClient.newHazelcastFailoverClient(clientFailoverConfig);

    System.out.println("Connection Successful!");

    nonStopMapExample(client); // <3>
  }
  private static ClientConfig getPrimaryClientConfig() throws Exception { // <4>
    ClassLoader classLoader = ClientWithSsl.class.getClassLoader(); 
    Properties props = new Properties(); 
    props.setProperty("javax.net.ssl.keyStore", classLoader.getResource("client.keystore").toURI().getPath());
    props.setProperty("javax.net.ssl.keyStorePassword", "YOUR_KEYSTORE_PASSWORD");
    props.setProperty("javax.net.ssl.trustStore",
       classLoader.getResource("client.truststore").toURI().getPath());
    props.setProperty("javax.net.ssl.trustStorePassword", "YOUR_KEYSTORE_PASSWORD");
    ClientConfig config = new ClientConfig();
    config.getNetworkConfig().setRedoOperation(true);
    config.getNetworkConfig().setSSLConfig(new SSLConfig().setEnabled(true).setProperties(props));
    config.getNetworkConfig().getCloudConfig()
       .setDiscoveryToken("YOUR_DISCOVERY_TOKEN")
       .setEnabled(true);
    config.setProperty("hazelcast.client.cloud.url", "YOUR_CLIENT_URL");
    config.setClusterName("YOUR_CLUSTER_ID");
    config.getConnectionStrategyConfig().getConnectionRetryConfig().setClusterConnectTimeoutMillis(10000); // <5> 
    return config;
    }

  private static ClientConfig getSecondaryClientConfig() throws Exception {
    ClassLoader classLoader = ClientWithSsl.class.getClassLoader(); // <6>
    Properties props = new Properties();
    props.setProperty("javax.net.ssl.keyStore", classLoader.getResource("client2.keystore").toURI().getPath()); // <7>
    props.setProperty("javax.net.ssl.keyStorePassword", "YOUR_KEYSTORE_PASSWORD");
    props.setProperty("javax.net.ssl.trustStore",
       classLoader.getResource("client2.truststore").toURI().getPath()); // <7>
    props.setProperty("javax.net.ssl.trustStorePassword", "YOUR_KEYSTORE_PASSWORD");
    ClientConfig config = new ClientConfig();
    config.getNetworkConfig().setRedoOperation(true);
    config.getNetworkConfig().setSSLConfig(new SSLConfig().setEnabled(true).setProperties(props));
    config.getNetworkConfig().getCloudConfig()
       .setDiscoveryToken("YOUR_DISCOVERY_TOKEN")
       .setEnabled(true);
    config.setProperty("hazelcast.client.cloud.url", "YOUR_CLIENT_URL");
    config.setClusterName("YOUR_CLUSTER_ID");
    config.getConnectionStrategyConfig().getConnectionRetryConfig().setClusterConnectTimeoutMillis(10000);
    return config;
    }
}

----
<1> Add import for the `ClientFailoverConfig` class.
<2> Create a `ClientFailoverConfig` object.
<3> For testing purposes, uncomment the `nonStopMapExample(client)` method.
<4> Add a private static method for `getPrimaryClientConfig`. This creates the config object for the primary cluster. 
<5> For testing purposes, set `setClusterConnectTimeoutMillis` to `10000` milliseconds or ten seconds. This reduces the timeout period before the failover client tries to connect to an alternative cluster.   
<6> Add a private static method for `getSecondaryClientConfig` with connection details for your secondary cluster.
<7> Rename keystore files from the Java client of your secondary cluster. 

[[step-3-testing]]
== Step 3. Verify Failover

Check that your failover client automatically connects to the secondary cluster when your primary cluster is stopped.

. Make sure that both Serverless clusters are running.
. Connect your failover client to the primary cluster in the same way as you did in <<step-1-setup, Step 1>>.
. Stop your primary cluster. From the dashboard of your primary cluster, select *Manage Cluster* > *Stop*. On the console, you'll see the following messages in order as the client disconnects from your primary cluster and reconnects to the secondary cluster:

** `CLIENT_DISCONNECTED`
** `CLIENT_CONNECTED`
** `CLIENT_CHANGED_CLUSTER`  

If you're using the `nonStopMapExample` in the sample Java client, your client stops. This is expected because write operations are not retryable when a cluster is disconnected. The client has sent a put request to the cluster but has not received a response, and so the result of the request is unknown. To prevent the client from overwriting more recent write operations, this write operation is stopped and an exception is thrown. 

[[step-4-exception-handling]]
== Step 4. Exception Handling

Update the `nonStopMapExample` in your failover client to trap the exception that is thrown when the primary cluster disconnects.

. Add the following try-catch block to your failover client.

.nonStopMapExample
[source,java]

----
while (true) {
  int randomKey = random.nextInt(100_000);
  try {
      map.put("key-" + randomKey, "value-" + randomKey);
  } catch (Exception e) {
      // Captures exception from the disconnected client
      System.out.println("Exception (" + e.getClass().getCanonicalName() + ") " + e.getMessage());
  }

----

[start=2]
. Repeat <<step-3-testing, Step 3>>. This time the client continues to write map entries after it connects to the secondary cluster.

== Summary

In this tutorial, you learned how to do the following:

* Collect all the resources that you need to create a failover client for a primary and secondary cluster.
* Create a failover client based on the sample Java client.
* Test failover.
* Add exception handling for operations that are not retryable.

== Learn More

Use these resources to continue learning:

- xref:cloud:ROOT:wan-replication.adoc[].

- xref:cloud:ROOT:charts-and-stats.adoc[].

- xref:cloud:ROOT:management-center.adoc[].
