= Go Client
:url-github-go: https://pkg.go.dev/github.com/hazelcast/hazelcast-go-client#hdr-Configuration

== Quick Setup

Follow the below instructions to connect a Go client to your cluster.

. xref:create-starter-cluster.adoc[Create a cluster].
+
The cluster-specific page will load and cluster's state will be "Pending" for some seconds, as shown below.
+
image:create-cluster-pending.png[A cluster being created]

. When the cluster's state becomes "Running", the previously inactive button `Configure Client` on this page becomes active. Click on it and the following dialog box appears:
+
image:go-client-dialog.png[Instructions for installing a Go client]

. Click on the Go tab (the Java tab is active by default) and download the ZIP file as instructed in Step 1 of the dialog box.

. Extract the ZIP file and run the command, in the extracted folder, shown in Step 2 of the above dialog box.

You should see log output similar to the following:

image:go-client-log.png[Go client logs that it is connected]

`Connection Successful!` in your logs means that your client application has successfully connected to your cluster in Hazelcast Cloud. The sample code inserts random entries to your cluster as you can see in the logs. In your Hazelcast Cloud console (your cluster's page where you can reach from the "Clusters" top menu), you should see the charts are being populated with metrics of your map, as shown below:

image:map-metrics-client-connection.png[Map metrics that show entries are being added to the map]

== Client Code

Now, as we have successfully connected and put data into the cluster, let's review and explain the client code you downloaded.

Go to the directory (extracted from the ZIP file you downloaded in the Step 3 above) and locate the client sample code. If you had enabled encryption in your cluster, open the `client_with_ssl.go` file. Otherwise, open the `client.go` file. We will explain both files line by line in the following sections.

=== client.go

This is the downloaded sample client code when your cluster does not have encryption.

[source,go]
----
package main

import (
  "context"
  "fmt"
  "log"
  "math/rand"
  "time"

  "github.com/hazelcast/hazelcast-go-client"
  "github.com/hazelcast/hazelcast-go-client/logger"
  "github.com/hazelcast/hazelcast-go-client/types"
)

func main() {
  // <1>
  config := hazelcast.Config{}
  cc := &config.Cluster
  cc.Name = "YOUR_CLUSTER_NAME" // <2>
  cc.Cloud.Enabled = true
  cc.Cloud.Token = "YOUR_CLUSTER_TOKEN" // <3>
  config.Stats.Enabled = true // <4>
  config.Stats.Period = types.Duration(1*time.Second)
  config.Logger.Level = logger.InfoLevel

  ctx := context.TODO()
  client, err := hazelcast.StartNewClientWithConfig(ctx, config) // <5>
  if err != nil {
    log.Fatal(err)
  }

  // <6>
  myMap, err := client.GetMap(ctx, "map")
  if err != nil {
    log.Fatal(err)
  }
  if _, err := myMap.Put(ctx, "key", "value"); err != nil {
    log.Fatal(err)
  }

  // <7>
  if _, err = myMap.Get(ctx, "key"); err != nil {
    client.Shutdown(ctx)
    log.Print("Connection failed, check your configuration: %s")
    log.Fatal(err)
  }
  log.Print("Successfully connected!")
  log.Print("Now, 'map' will be filled with random entries.")
  rand.Seed(time.Now().UTC().UnixNano())
  counter := 0
  for {
    r := rand.Int63n(100_000) + 1
    key := fmt.Sprintf("key%d", r)
    value := fmt.Sprintf("value%d", r)
    if _, err = myMap.Put(ctx, key, value); err != nil {
      log.Fatal(err)
    }
    if _, err = myMap.Get(ctx, key); err != nil {
      log.Fatal(err)
    }
    counter++
    if counter % 10 == 0 {
      size, err := myMap.Size(ctx)
      if err != nil {
        log.Fatal(err)
      }
      fmt.Println("Map size:", size)
    }
    time.Sleep(100*time.Millisecond)
	}
}
----

<1> First, we create an empty client configuration.

<2> Then, we set the cluster name via `Cluster`.
+
The cluster name and password are unique to your cluster. The client is authenticated using this password.

<3> Then, we set the Hazelcast Cloud token.
+
This token is also unique to your cluster and used to discover Hazelcast cluster members.

<4> We enable Hazelcast to send the client statistics to see them in the cluster's page.

<5> Now, we create the client with `config`.
+
This step creates the connection between your application and the cluster.

<6> We get/create a map and put a simple entry ("key", "value").

<7> Then, we check if the entry has been added and let the code log and fail with an error if the value is not correct. Finally, we add random entries with 100-millisecond intervals.

=== client_with_ssl.go

This is the downloaded sample client code when your cluster has encryption enabled.

[source,go]
----
package main

import (
  "context"
  "fmt"
  "log"
  "math/rand"
  "time"

  "github.com/hazelcast/hazelcast-go-client"
  "github.com/hazelcast/hazelcast-go-client/logger"
  "github.com/hazelcast/hazelcast-go-client/types"
)

func main() {
  // <1>
  config := hazelcast.Config{}
  cc := &config.Cluster
  cc.Name = "YOUR_CLUSTER_NAME" // <2>
  cc.Cloud.Enabled = true
  cc.Cloud.Token = "YOUR_CLUSTER_TOKEN" // <3>
  cc.Network.SSL.Enabled = true
  cc.Network.SSL.SetTLSConfig(&tls.Config{ServerName: "hazelcast.cloud"})
  if err := cc.Network.SSL.SetCAPath("ca.pem"); err != nil {
    log.Fatal(err)
  }
  if err := cc.Network.SSL.AddClientCertAndEncryptedKeyPath("cert.pem", "key.pem", "YOUR_SSL_PASSWORD"); err != nil {
    log.Fatal(err)
  }
  config.Stats.Enabled = true // <4>
  config.Stats.Period = types.Duration(1*time.Second)
  config.Logger.Level = logger.InfoLevel

  ctx := context.TODO()
  client, err := hazelcast.StartNewClientWithConfig(ctx, config) // <5>
  if err != nil {
    log.Fatal(err)
  }

  // <6>
  myMap, err := client.GetMap(ctx, "map")
  if err != nil {
    log.Fatal(err)
  }
  if _, err := myMap.Put(ctx, "key", "value"); err != nil {
    log.Fatal(err)
  }

  // <7>
  if _, err = myMap.Get(ctx, "key"); err != nil {
    client.Shutdown(ctx)
    log.Print("Connection failed, check your configuration: %s")
    log.Fatal(err)
  }
  log.Print("Successfully connected!")
  log.Print("Now, 'map' will be filled with random entries.")
  rand.Seed(time.Now().UTC().UnixNano())
  counter := 0
  for {
    r := rand.Int63n(100_000) + 1
    key := fmt.Sprintf("key%d", r)
    value := fmt.Sprintf("value%d", r)
    if _, err = myMap.Put(ctx, key, value); err != nil {
      log.Fatal(err)
    }
    if _, err = myMap.Get(ctx, key); err != nil {
      log.Fatal(err)
    }
    counter++
    if counter % 10 == 0 {
      size, err := myMap.Size(ctx)
      if err != nil {
        log.Fatal(err)
      }
      fmt.Println("Map size:", size)
    }
    time.Sleep(100*time.Millisecond)
  }
}
----

<1> The only difference between this one and the `client.go` is the lines that enable and configure TLS encryption on the client side.

Note that you have to export the following environment variable for code compiled with Go 1.15 or Go 1.16: `GODEBUG=x509ignoreCN=0`. Go 1.17 is not supported.

You may want to move the 'pem' files to another directory. Then, you need to set 'ca', 'cert' and 'key' file directories accordingly.

== More Configuration Options

Please refer to the link:{url-github-go}[Hazelcast Go Client Documentation] for further configuration options.